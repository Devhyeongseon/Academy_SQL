--집합연산자
--UNION = 합집합(중복X)
--UNION ALL = 합집합(중복O)
--INTERSECT = 교집합
--MINUS = 차집합

--컬럼개수가 일치해야 집합연산자 사용이 가능합니다.
SELECT FIRST_NAME, HIRE_DATE /*, DEPARTMENT_ID*/ FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--------------------------
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--------------------------
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--------------------------
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--UNION ALL은 가상테이블을 만들때 사용이 가능합니다.
SELECT 200 AS EMPLOYEE_ID, 'HONGKILDONG' AS NAME FROM DUAL
UNION ALL
SELECT 300, 'LEE' FROM DUAL
UNION ALL
SELECT 400, 'PARK' FROM DUAL;

--------------------------------------------------------------------------------
-- 시험의 단골문제라서 기억하기
-- 분석함수
SELECT EMPLOYEE_ID,
       FIRST_NAME,
       SALARY,
       RANK() OVER(ORDER BY SALARY DESC) AS 중복등수, -- 분석함수는 OVER(조건)과 반드시 함께 사용됩니다
       DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 중복없는등수,
       ROW_NUMBER() OVER(ORDER BY SALARY ASC) AS 일련번호
FROM EMPLOYEES;

-- ROWNUM과의 차이? - ROWNUM은 ORDER BY 시에 결과가 바뀝니다
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY;










